//
//  main.swift
//  01 基本语法
//
//  Created by Li_JinLin on 2017/6/14.
//  Copyright © 2017年 Li_JinLin. All rights reserved.
//

import Foundation

print("Hello, World!-->01基本语法")
/********************************************一、基本语法*************************************************/
/*****************************01常量和变量*********************************/
//01.1常量
let a:Int = 10
let b = 10
let c:Int
c = 10
let e:Int,f:String,g = 10
print(a,b,c,g)
//变量
var x:Int =  20
var y:Int
y = 30
//(变量类型不能省略)
var m = 4
var t:Int = 9,h = 10,k:Int
print(x,y,m,t,h)
/*
 tips:
 1、swift对命名比较宽松，可以使用字符，下划线，中文，图像符号等，但是不能以数字开头；
 2、常量和变量的名称不能复用，不能使用swift内置的关键字
 3、变量的值在第一次赋值之后可以改变多次。
 4、swift区分大小写，大小写字母视为不同的字符
 5、常量和变量不能互转
 6、常量和变量都没有默认值，在使用之前必须先赋值，否则会编译失败
 */

/*
    多学一招 ： 按住option 再用鼠标点击常量可显示常量类型
 */

/**********************************02类推断和类型安全*****************************/

let ab = "test"    //String
let bb = 10        //Int
let cc = 5.5 + 2   //double
var aa = true      //bool
let ww = 10.5
let num1 = bb + Int(ww)
/*
 tips:1、在C和OC中，数据类型是可以自动转换的，但是在swift中不允许任何形式的数据类型自动转换，只能强制转换
      2、两个类型不同的变量或者常量都不允许直接计算
 */

/**********************************03输出变量和常量*******************************/
//输出的方式
//02.1直接输出
print("hello");print(5)
//02.2输出常量或者变量的值
var i = "string";let u = 10
print(i,u)
//02.3、将常量或者变量加入字符串中显示
let mm = "dahuatech"
print("www.\(mm).com")
//02.4、多种格式输出
let kk = "滨安路1199号"
let web = "www.dahuatech.com"
print("地址:\(kk),","网址：\(web)")

/**********************************04简单数据类型*******************************/
//（1）整型：按符号分为1、有符号的整型，能表示正数、负数 0；2、无符号正数和0
   //UInt8 无符号8位整数（0~255） Int8 有符号8位整型（-128~127）
   //整型字面量
let a1 = 17     //十进制
let a2 = 0b10001  //二进制
let a3 = 0o21   //八进制
let a4 = 0x11   //十六进制
//(2)、浮点型
let a5:Double = 3.141    //double表示64位浮点型，精确度高
let a6:Float = 2.33      //float标识32位浮点数，当精确度不高时可以使用
let a55 = 3_500_200       //表示3500200
let a66 = 003.00          //表示3.00
let a7 = 1.25e2          //表示1.25 * 10^2    等于125
let a8 = 1.25e-2         //表示1.25 *10^-2 等于0.0125
//(3)、bool类型
let hasError = false
var hasResult = true
if hasError {
    print("出错了")
} else {
    print("正常")
}

/**********************************05元组类型Tuples*******************************/
//把多个值组合成一个复合值，这个复合值就叫做元组类型，即元组。应用场景，例HTTP状态码404和提示信息“Not Found”
//5.1元组的声明
//5.1.1元组类型的字面量
//字面量格式:1、(元素值1，元素值2，元素值3，元素值4......元素值n)例如，("小明"，18，“男”)
         //2、采用键值对的方式:(元素名称1：元素值1，元素名称2：元素值2) 例如（name:"小明"，age:18,gender:"男"）
//5.1.2声明元组类型常量和变量以及访问
//let 常量名 = 元组类型的字面量
//var 变量名 = 元组类型的字面量
//例如
let student1 = ("小明",18,"男")
var student2  = (name:"小红",age:18,gender:"女")
print(student1)
print("学生信息：\(student2)")
print(student1.0)
//5.1.3匿名元组
let (name,age,gender) = student1
print("姓名：\(name),年龄:\(age),性别:\(gender)")
let (name1,age2,gender1) = (name:"alis",age:18,gender:"女")
//如果只需要一部分元组值，则可以将不需要的元素用_来标记
let (name2,_,_) = ("Tom","Student",18)
print("学生姓名\(name2)")
//5.1.3元组的比较
let jack = ("Jack",20)
let rose = ("Rose",20)
/*
 使用==对元组进行比较:
 tips：1、使用==操作符只能对最多含有6个元素的元组进行比较，这样设计的考虑是
        （1）、标准库的复杂度问题
        （2）、元组的使用场景是针对含有少量元素的中，如果元素过多，建议使用struct结构体来表示
       2、在对元组进行比较式，会忽略元组的元素名称，比如
         let jack = ("Jack",20)
         let rose = ("Rose",18)
 */
var isEqual = false
if (jack.1 == rose.1) {
    isEqual = true
    print("相等")
} else {
    print("不等")
}
/**********************************06基本运算符*******************************/
//tip:特性改进 swift 赋值运算符 = 不 返回值 例 (if a=b),这是错误的。算术运算符（+ - * / %等）会检测并不允许值溢出，以此避免保存变量时，由于变量超出其类型所能承载的范围时导致的异常

//6.1赋值运算符 a=b,表示用b去初始化或者更新a的值
let b2 = 10
var b3 = 8
b3 = b2
//元组,会对元素分别赋值
let (hh,yy) = (3,4)
print("测试基本运算符元组的赋值hh:\(hh),yy:\(yy)")

//6.2单目运算符 - 用于切换数值类型的负正
var b4 = 10
var b5 = -b4
b4 = -b5
//6.3.1算术运算符+ - * / %
//例如 2 + 1  6 - 4  2 * 3  8.0 / 2.0

//tip 1、与OC和C不同的是， swift不允许在数值运算中出现溢出的情况，编译器会检测并报错  2、+运算符可以使用在字符串的拼接
var testStr = "dahua" + "tech"
print(testStr)
//6.3.2求余运算符
let b6 = 5 / 2   // 2
let b7 = 5 % 2   // 1
//负数求余
let b8 = -9 % 2    //-1
let b9 = -9 % -2   //-1
let b10 =  9 % -2  //1
/*
 tip:
 1、求余操作的结果是正还是负，由求余操作符左边的被除数来决定。
 2、在swift3.0中对浮点数求余不能使用%运算符，使用truncatingRemainder函数,例：let b11 = (7.5).truncatingRemainder(dividingBy: 2) //结果为1.5
 */
//复合赋值运算符
var ab1 = 20
let ab2 = 5
ab1 += ab2
print(ab1)
ab1 -= ab2
print(ab1)
ab1 *= ab2
print(ab1)
ab1 /= ab2
print(ab1)
ab1 %= ab2
print(ab1)
/*
 tip:1、复合赋值运算符没有反沪指，所以 let ab3 = ab1 += ab2的表达是错误的
     2、从swift2.2开始，去掉了C语言中继承来的自增++和自减--，可以使用+= -=来代替
 */
//6.4比较运算符
//==  !=  >   <  >=  <=
//比较运算符返回bool类型
let nameStr1 = "nameStr1"
let nameStr2 = "nameStr2"
if nameStr1 == nameStr2 {
    print("\(nameStr1)和\(nameStr2)相等")
} else {
    print("\(nameStr1)和\(nameStr2)不相等")
}
//6.5三目运算符
//格式： a ? b : c  a必须为Bool类型
//6.6逻辑运算符
//逻辑非 逻辑与 逻辑或 !a   a && b    a|| b 
//组合逻辑运算符 a && b || ac && d  &&的优先级高于||
//6.7区间运算符
/*
  tips
    6.7.1 闭区间运算符
          a...b等同 a<= x <= b
          例 for  i in 1...5 {}
    6.7.2 半闭区间运算符
          a..<b 等同 a <= x < b
 
 */
/**********************************07可选类型Optional*******************************/
//应用场景：在程序中，经常会遇到一个数据可能有值，可能没有值的情况，针对这种情况，swift增加了optional可选类型
//一个可选类型的常量或变量说明它可以有一个指定值可选类型可用于声明所有的数据类型，包括基础数据类型、类、结构体.
//7.1 可选类型的声明
  //7.1.1可选常量
         //格式： let 常量名:常量类型 ?= 常量值
         //注意:  声明可选类型必须指定常量类型，常量类型可以是任何类型，声明时，可以指定常量值，也可以不指定，等以后再赋值
         //例如  let a:Int? print(a),此时在打印时必须给a赋初始值，不然会编译失败
  //7.1.2可选变量
         //格式： var 变量名：变量类型 ?= 变量值
         //var b:Int?  print(b) b 没有初始值，但此时不会报错 此时b的值为nil
         //tip：1、声明可选变量必须指定变量类型，变量类型可以是任何类型，变量值可以省略（和常量的区别） 2、在开发中，可以给可选项）—可选常量和可选变量赋值为nil表示没有值，只有可选项才能赋值为nil
 /*
    tips: 1、swift中的nil和OC中的nil不一样。在OC中nil表示为一个空指针，只能用于对象，而在swift中没有指针的概念，nil的含义是一个值，表示值的缺失，swift中的nil可用于任何类型的可选项，不仅仅是对象
          2、可选类型的标准类型,Optional<T>,T代表数据类型.var optionalInteger:Optional<Int> 等同 //var optionalInteger2:Int? 。类型Optional<T>是一个枚举类型，有两个成员，None 和 Some（T）用来表示可能有也可能没有值，任何类型都可以被显示地声明（或者隐式地转换）为可选类型，如果没有初始值，则为nil
          3、可选项不能直接参与计算
 */
//7.2 解包(Unwrapping) 
//可选项不能直接参与计算，例 var a:Int? = 10 printf(a + 10) 此时会编译不通过，提示信息为：“可选类型Int?没有解包，请使用！进行解包Unwrapping”,要使用可选中，必须对它进行解包，使用！解包
let ca1:Int? = 10
print("测试可选项的解包\(ca1! + 2)")
//tip:解包时出错,例如
//let ca2:Int?
//print(ca2! + 10) 编译失败的原因就是ca2中没值，所以在解包的过程中取不到值故在强制解包时，一定要确保可选项中有非nil的值，使用if对它进行提前判断
//7.3 隐式解析可选类型
//当能确定一个可选类型有值的时候，可以直接使用隐式解析可选类型，隐式解析可选类型的方法是将数据类型后面的？改为！，
//例如：声明两个隐式解析的可选常量和可选变量
let ca3:Int! = 2
var ca4:Int! = 3
//隐式解析可选类型本质上是一个可选类型，但是可以被当做非可选类型来取值，可以把它当做一个自动解析的可选类型。
//可选类型和隐式可选类型的区别
let possibleString:String? = "可选项"
let forcedString:String = possibleString!   //需要！来获取值
let assumeString:String! = "隐式解析可选项"
let implicitString:String = assumeString    //不需要！
/*
    tips: 1、不能将隐式解析可选类型设置为nil 例如var x:Int? = 10 x = nil print(x) 此时打印值为nil;y:Int! = 10,y = nil print(y)此时会出错
          2、空合并运算符 ?? 
             空合并运算符用于对可选类型进行空判断，如果包含阿胡子就对可选常量、变量进行解包，如果为nil就返回一个默认值，空合并运算符使用默认值替换nil值，处理了nil值的情况
          空合并语法结构： a ?? b 可理解为 a != nil ? a!:b,当可选类型a不为空时，对a进行强制解包，取出a的值，反之，a为空的时候，返回值b,其中b可以为字面量、常量、变量或者是表达式等
          条件: 1、表达式a必须是可选类型 2、默认值b的数据类型必须与a的数据类型一致
 */
let num11:Int? = nil
let num2 = (num11 ?? 0) + 10  // num11为nil,所以 0 + 10 = 10
let num22:Int? = 2
let num3 = (num22 ?? 0) + 10  // num22不为nil所以 2 + 10 = 12





























































